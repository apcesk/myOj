/*
* ------------------------------------------------------
* |自己:解题思路                                         
* |  - 原本想着n的数据也不大，最大才18，用递归去算应该能够解决   
* |  - 但是实际上可能并不行   
* |  - 于是去看了一下评论区的大佬想法
* |  - 核心是用递推找规律
* |  - 奈何我等蒟蒻​找不到规律
* |  - 下面是核心重点
* ------------------------------------------------------
*
* ------------------------------------------------------
* |大神:解题思路                                         
* |  - 递推,f[0] = 1, f[1] = 1,初始化边界，f[i]代表i个数字出栈的总可能数
* |  - 假设最后一个出栈的数是x，说明x有n种取值
* |  - 则有如下两种情况
* |  - 1:比x小的，出栈可能共有f[x-1]种。
* |  - 2:比x大的，出栈的可能共有f[n-x]种。
* |  - 由于1和2之间组成的输出顺序是互相影响的，所以一个x的取值，能够得到的所有的输出可能性为f[x-1] * f[n-x]
* |  - 基于x有n种取值
* |  - 于是 ans = f[0] * f[n-1] + f[1] * f[n-2] + ... + f[n-1] * f[0];
* |  - 这就是卡特兰数
* |  - PS:以上内容来自于洛谷的该题评论，详情请见https://www.luogu.com.cn/problem/solution/P1044
* ------------------------------------------------------
*/
#include<cstdio>
#include<iostream>
using namespace std;
int f[20];// 总共也就20个数字
int n;// 输入的n
int main(){
    // 代码的实现
    // 递推边界
    f[0] = 1, f[1] = 1;
    scanf("%d", &n);
    // 递推公式求解
    for (int i = 2;i <= n;++i){
        for (int j = 0;j < i;++j){
            f[i] += f[j] * f[i-j-1];
        }
    }
    printf("%d", f[n]);
    return 0;
}