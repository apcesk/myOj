#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
/*
    给定前序和后序，问有几种中序的可能。
    首先要明确为什么一定要有中序才能够确定该树型结构的唯一性？
    由于有了中序遍历，说明能够确定该树形结构左右子树，就能够确立该树的形状。
    但是由于没有中序遍历，加上"每个节点都只有一个子节点"，导致了知道树形结构的前序和后序而无法得知其中序。
    "简单理解，当只有前序后后序遍历时，如果有的节点只有一个子节点，则无法判别该子节点应当所在的位置"
    例如:
        先序:abdc
        后序:bdca
        那么你能够根据这个样例得出中序遍历有几种呢？
    答案:
        1种！
    为何:
        abdc先序
        bdca后序
        自己动手去左一下！
    再例如:
        先序:abc
        后序:cba
    答案:
        4种！
    为何:
        动手试一下！
        再去看题！
*/
int ans = 1;//存储答案,最少的情况有1种
char str1[300], str2[300];
int main(){
    scanf("%s",str1);
    scanf("%s",str2);
    for(int i = 0;i < strlen(str1);i++){
        for (int j = 1;j < strlen(str2);j++){
            if (str1[i] == str2[j] && str1[i+1] == str2[j-1]){
                //如果当前的节点相同，说明先序遍历该节点的下一个可以是左子节点，也可以是右子节点-> 根左右
                //后序遍历也是如此，只不过下一个节点变成当前的节点的上一个节点 -> 左右根
                ans *= 2;
            }
        }
    }
    printf("%d",ans);
    return 0;
}